name: AsusRouter Bot

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

jobs:
  process-issue:
    name: Process Issue
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Process Issue
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            const issueTitle = issue.title || '';
            
            console.log('Processing issue:', issue.number);
            console.log('Title:', issueTitle);
            
            // Extract device model from issue body
            function extractDeviceModel(body) {
              const patterns = [
                /### Device model\s*\n\s*([^\n\#]+)/i,
                /Device model[^:]*:?\s*([^\r\n]+)/i,
                /Your device model[^:]*:?\s*([^\r\n]+)/i,
                /Model[^:]*:?\s*([^\r\n]+)/i
              ];
              
              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match && match[1] && match[1].trim() !== '' && match[1].trim() !== '_No response_') {
                  const value = match[1].trim();
                  // Skip placeholder values and check if it looks like a valid device model
                  if (value === 'RT-' || value.length < 2 || value.startsWith('###')) {
                    continue;
                  }
                  return value;
                }
              }
              return null;
            }
            
            // Extract firmware version from issue body
            function extractFirmwareVersion(body) {
              const patterns = [
                /### Firmware version\s*\n\s*([^\n\#]+)/i,
                /Firmware version[^:]*:?\s*([^\r\n]+)/i,
                /Version[^:]*:?\s*([^\r\n]+)/i
              ];
              
              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match && match[1] && match[1].trim() !== '' && match[1].trim() !== '_No response_') {
                  const value = match[1].trim();
                  // Skip placeholder values and check if it looks like a valid firmware version
                  if (value === '3.0.0.4.' || value.length < 3 || value.startsWith('###')) {
                    continue;
                  }
                  return value;
                }
              }
              return null;
            }
            
            // Check if required details are provided
            function hasRequiredDetails(body) {
              const detailsPatterns = [
                /### Bug details\s*\n\s*([^\n]+)/i,
                /### Support details\s*\n\s*([^\n]+)/i,
                /### Feature request details\s*\n\s*([^\n]+)/i,
                /Bug details[^:]*:?\s*([^\r\n]+)/i,
                /Support details[^:]*:?\s*([^\r\n]+)/i,
                /Feature request details[^:]*:?\s*([^\r\n]+)/i,
                /The problem[^:]*:?\s*([^\r\n]+)/i
              ];
              
              for (const pattern of detailsPatterns) {
                const match = body.match(pattern);
                if (match && match[1] && match[1].trim() !== '' && match[1].trim() !== '_No response_') {
                  return true;
                }
              }
              return false;
            }
            
            // Determine issue type and correct title prefix
            let issueType = null;
            let correctTitle = issueTitle;
            let expectedLabels = [];
            
            if (issueTitle.toLowerCase().includes('bug') || issueBody.toLowerCase().includes('bug details')) {
              issueType = 'bug';
              if (!issueTitle.startsWith('[Bug]')) {
                correctTitle = '[Bug] ' + issueTitle.replace(/^\[.*?\]\s*/, '');
              }
              expectedLabels.push('bug');
            } else if (issueTitle.toLowerCase().includes('support') || issueBody.toLowerCase().includes('support details')) {
              issueType = 'device_support';
              if (!issueTitle.startsWith('[Support]')) {
                correctTitle = '[Support] ' + issueTitle.replace(/^\[.*?\]\s*/, '');
              }
              expectedLabels.push('documentation');
            } else if (issueTitle.toLowerCase().includes('feature') || issueBody.toLowerCase().includes('feature request details')) {
              issueType = 'feature_request';
              if (!issueTitle.startsWith('[Feature]')) {
                correctTitle = '[Feature] ' + issueTitle.replace(/^\[.*?\]\s*/, '');
              }
              expectedLabels.push('enhancement');
            }
            
            // Extract information
            const deviceModel = extractDeviceModel(issueBody);
            const firmwareVersion = extractFirmwareVersion(issueBody);
            const hasDetails = hasRequiredDetails(issueBody);
            
            console.log('Extracted info:', { issueType, deviceModel, firmwareVersion, hasDetails });
            
            // Add device model label if found
            if (deviceModel) {
              expectedLabels.push(`device: ${deviceModel}`);
            }
            
            // Check for missing required information
            const missingInfo = [];
            if (issueType === 'bug' || issueType === 'device_support') {
              if (!deviceModel) {
                missingInfo.push('**Device model**');
              }
              if (!firmwareVersion) {
                missingInfo.push('**Firmware version**');
              }
            }
            if (!hasDetails) {
              if (issueType === 'bug') {
                missingInfo.push('**Bug details**');
              } else if (issueType === 'device_support') {
                missingInfo.push('**Support details**');
              } else if (issueType === 'feature_request') {
                missingInfo.push('**Feature request details**');
              }
            }
            
            // Update title if needed
            if (correctTitle !== issueTitle) {
              console.log('Updating title from:', issueTitle, 'to:', correctTitle);
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                title: correctTitle
              });
            }
            
            // Add labels
            if (expectedLabels.length > 0) {
              console.log('Adding labels:', expectedLabels);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: expectedLabels
              });
            }
            
            // Comment if missing required information
            if (missingInfo.length > 0) {
              const commentBody = 'ðŸ‘‹ Hello! Thank you for opening this issue.\n\nI noticed that some required information is missing from your issue. To help us assist you better, please provide the following:\n\n' + missingInfo.map(item => '- ' + item).join('\n') + '\n\nPlease edit your issue to include this information. Thank you! ðŸ¤–';

              console.log('Adding comment for missing info:', missingInfo);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: commentBody
              });
            }